;
var moduleA = (
  //导出对象
  function(){
    var obj;
    var s = function(){

    }
    var flag;
    obj.flag = flag;
    obj.s = s;
    return obj;
  }
)()

// 没有模块化，前端代码会怎么样？
//     变量和方法不容易维护，容易污染全局作用域
//     加载资源的方式通过script标签从上到下。
//     依赖的环境主观逻辑偏重，代码较多就会比较复杂。
//     大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃。


// 当年我们是怎么引入资源的?
//     通过script引入你想要的资源，从上到下的顺序，这其中顺序是非常重要的，
// 资源的加载先后决定你的代码是否能够跑的下去。当然我们还没有加入defer和async属性，
// 不然加载的逻辑会更加复杂。这里引入的资源还是算少的，过多的script标签会造成过多的请求。同时项目越大，到最后依赖会越来越复杂，并且难以维护，依赖模糊，请求过多。全局污染的可能性就会更大。

//模块化的基石:
//Javascript 的模块化最初是使用闭包来实现的. 使用闭包包裹变量, 以屏蔽外界的访问来形成模块.
//1，匿名函数解决变量的声明与作用域，
//2，返回函数解决代码复用性

//目前常见的模块化方案：*CommomJS  {  module.export{ }   const {  } = require("")   }                 (AMD\CMD)不常用
//                    *ES6的Modules  { export{}     import    from      }  